/*
 * photosensor_10seg.c
 *
 *  Created on: Feb 16, 2022
 *      Author: bailey-waltzo
 ***************************************
 * EE 1910 LAB 7
 * Owen Bailey
 * Program to increment LED bar lights
 * based on button presses
 *
 * INPUTS:  Photodiode, one switch,
 *          optionally one button for
 *          mode 2
 * OUTPUTS: Binary value of measured
 *          light from 0 to 1023 on ten
 *          segment LED bar
 ***************************************/

#include <stdio.h>
#include <stdint.h>
#include "msp.h"

// environment-specific light values for 0% and 100% respectively
#define DARK 3540
#define LIGHT 1410

// function prototypes (reusing the ADC functions from the previous photodiode lab)
int adc0_setup(void);
int adc0_convert(void);
void led_setup(void)
void button_setup(void);
void switch_setup(void);
void update_mode(int *mode_ptr, const volatile uint8_t *pin_reg, uint8_t pin_mask);
void check_button(int *pin_val_ptr, const volatile uint8_t *pin_reg, uint8_t pin_mask);
void button_change(int pin_val, int *pin_old_ptr, int *pin_changed_ptr);
void led_out(volatile uint8_t *pin_reg, int light);

// setup A0 at pin 30 for A/D conversion
int adc0_setup(void)
{
    P5->SEL0 |= 0x20; // select alternate mode 11
    P5->SEL1 |= 0x20;
    P5->DIR &= ~0x20; // input
    P5->REN &= ~0x20;

    // enable A0 pin
    ADC14->CTL0 = 0x04000210;   // S/H timer, 16clk S/H, ADC ON
    ADC14->CTL1 = 0x00000020;   // 12-bit conversion
    ADC14->MCTL[0] = 0x00000000; // Vref = AVCC

    return 0;
}

int adc0_convert(void)
{
    // start sampling
    ADC14->CTL0|= 0x00000003; // enable ADC, start conversion

    // wait for conversion to complete
    while (!ADC14->IFGR0)
    {
        ;
    }

    return ADC14->MEM[0];
}

// setup LEDs to P4.0-4.7 and P5.0-5.1
void led_setup(void)
{
    P4->DIR |= 0xFF; // everything on port 4 to output
    P4->OUT &= 0x00; // initialize first eight LEDs to off
    P5->DIR |= 0x03; // pin 0 and pin 1 of port 5 to output
    P5->DIR &= ~0x03; // initialize last two LEDs to off
}

// set up button
void button_setup(void)
{
    // button on P6.0
    P6->DIR &= ~0x01; // xxxx xxx0
}

// set up switch on P3.0
void switch_setup(void)
{
    P3->DIR &= ~0x01;  // same thing
}

// debounce pin and read button state
void check_pin(int *pin_val_ptr, const volatile uint8_t *pin_reg, uint8_t pin_mask)
{
    // check input twice separated by 5ms to debounce pin
    // temporary variable declarations
    uint8_t pin_val_a;
    uint8_t pin_val_b;

    // first check
    pin_val_a = *pin_reg & pin_mask;

    // debounce delay 5ms
    __delay_cycles(5 * (CLOCKRATE / 1000));

    // second check
    pin_val_b = *pin_reg & pin_mask;

    // check for change
    if (pin_val_a == pin_val_b)
        *pin_val_ptr = pin_val_a && 1;
    else
    {
        ;
    }
    return;
}

// check to see whether a pin has changed
void pin_change(int pin_val, int *pin_old_ptr, int *pin_changed_ptr)
{
    if (pin_val != *pin_old_ptr)
    {

        *pin_old_ptr = pin_val;
        *pin_changed_ptr = 1;
    }
    else if (pin_val == *pin_old_ptr)
        *pin_changed_ptr = 0;
}
